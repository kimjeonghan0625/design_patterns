## Command 패턴


### 설명

Command 패턴의 기본 아이디어는 **동작(action)을 별도의 객체로 분리하고, 이를 파라미터로 전달**하는 것입니다.


### 동기
우리가 일련의 동작이나 트랜잭션을 객체로 캡슐화해 놓았다고 가정해 봅시다. 이러한 동작이나 명령들은 나중에 어떤 순서로 실행되거나 호출되기를 원할 수 있습니다. 이 명령들은 어떤 이벤트의 결과로 트리거될 수도 있습니다. 예를 들어, 사용자가 버튼을 누르거나 데이터 패킷이 도착했을 때처럼 말입니다.

또한, 이러한 명령들은 **되돌릴 수 있어야 할 수도 있습니다**. 이는 예를 들어 **에디터의 작업**과 같은 경우에 유용할 수 있습니다. 우리는 실행된 명령들의 로그를 저장해 두었다가, **시스템이 충돌했을 때 해당 변경 사항들을 다시 적용**하고 싶을 수도 있기 때문입니다.


## 예제
두 가지 데이터베이스 작업인 **테이블 생성(create table)** 과 **필드 추가(add field)** 를 정의해 봅시다. 이 각각의 작업은 **해당 작업을 되돌릴 방법**(예: drop table, remove field)을 알고 있는 **명령(command)** 입니다.

사용자가 데이터베이스 마이그레이션 작업을 실행하면, 이 명령들은 **정해진 순서대로 실행**됩니다. 반대로 사용자가 롤백 작업을 실행하면, 전체 명령 집합이 **역순으로 실행**됩니다.


## 접근법 1: Trait 객체를 이용한 구현

우리는 `execute`와 `rollback`이라는 두 가지 동작을 캡슐화한 **공통 트레이트**를 정의합니다.
모든 명령 구조체는 이 트레이트를 **반드시 구현해야 합니다.**


## 접근법 2: 함수 포인터를 이용한 구현

또 다른 접근 방식으로는, 각 명령을 **별도의 함수로 정의**하고, 이러한 함수들을 **나중에 호출할 수 있도록 함수 포인터로 저장하는 방법**이 있습니다.
함수 포인터는 `Fn`, `FnMut`, `FnOnce` 이 세 가지 트레이트를 모두 구현하므로,
**함수 포인터 대신 클로저를 전달하고 저장하는 것도 가능합니다.**


## 접근법 3: `Fn` 트레이트 객체를 이용한 구현

마지막으로, **공통 명령 트레이트를 정의하는 대신**,
각 명령을 `Fn` 트레이트를 구현한 **개별 클로저로 만들어 벡터에 따로 저장할 수도 있습니다.**


## 논의

명령들이 작고 함수로 정의되거나 클로저로 전달될 수 있다면, **동적 디스패치를 사용하지 않는** 함수 포인터를 사용하는 것이 더 바람직할 수 있습니다.
하지만 명령이 여러 함수와 변수를 포함한 **전체 구조체**로 별도 모듈에 정의되어 있다면, **트레이트 객체를 사용하는 것이 더 적절합니다.**
예를 들어, `actix`에서는 라우트 핸들러 함수를 등록할 때 트레이트 객체를 사용하는 사례를 볼 수 있습니다.

`Fn` 트레이트 객체를 사용하는 경우에도, **명령을 생성하고 사용하는 방식은 함수 포인터를 사용할 때와 동일하게 처리할 수 있습니다.**

성능 측면에서는, **항상 성능과 코드의 단순성 및 구조화 사이에 트레이드오프가 존재합니다.**
정적 디스패치는 더 빠른 성능을 제공하지만, **동적 디스패치는 애플리케이션 구조를 유연하게 설계할 수 있는 장점이 있습니다.**


## 함께 참고할 것

* [Command 패턴 설명 (GoF 패턴 중 하나)](https://en.wikipedia.org/wiki/Command_pattern)
* [Rust에서의 Command 패턴 적용 예시들](https://web.archive.org/web/20210223131236/https://chercher.tech/rust/command-design-pattern-rust)
